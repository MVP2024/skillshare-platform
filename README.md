# SkillShare Platform Backend

![Django](https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=django&logoColor=green)
![Django REST Framework](https://img.shields.io/badge/DRF-FF1709?style=for-the-badge&logo=django&logoColor=white)
![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)
![PostgreSQL](https://img.shields.io/badge/PostgreSQL-316192?style=for-the-badge&logo=postgresql&logoColor=white)
![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white)
![GitHub](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white)
![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white)

## Описание проекта

Этот проект представляет собой бэкенд для платформы онлайн-обучения, аналогичной SkillShare, разработанный с
использованием Django и Django REST Framework. Он предоставляет API для управления пользователями, курсами, уроками и
платежами.

### Основные возможности:

* **Управление пользователями**: Регистрация, авторизация, профили пользователей.
* **Курсы и уроки**: Создание, просмотр, обновление и удаление курсов и уроков.
* **Платежи**: Запись и отслеживание платежей за курсы и уроки.
* **Фильтрация и сортировка**: Гибкие возможности для поиска и упорядочивания платежей.
* **История платежей**: Просмотр истории платежей в профиле пользователя.
* **Ролевая модель доступа**: Разграничение прав доступа для суперпользователей, модераторов и обычных пользователей (
  владельцев контента).
* **Автоматическая пагинация**: Пагинация списков курсов и уроков для оптимизации загрузки данных.
* **Загрузка начальных данных**: Кастомная команда для удобной загрузки тестовых данных (пользователей, курсов, уроков,
  платежей, групп).
* **Платежная система**: Интеграция со Stripe для обработки платежей за курсы и уроки.
* **Фоновые задачи с Celery**:
    * Асинхронная отправка уведомлений об обновлении курсов.
    * Периодическая деактивация неактивных пользователей.

## Структура проекта

* `skillshare_platform/`: Основные настройки проекта Django, корневые URL-адреса.
* `users/`: Приложение для управления пользователями, их профилями и платежами. Содержит модели `User` и `Payment`,
  сериализаторы, представления и URL-адреса.
* `materials/`: Приложение для управления учебными материалами (курсами и уроками). Содержит модели `Course` и `Lesson`,
  сериализаторы, представления и URL-адреса.
* `media/`: Директория для хранения загружаемых пользователями файлов (аватары, превью курсов/уроков).
* `env/`, `.venv/`: Виртуальные окружения (игнорируются Git).
* `.env`, `.env.example`: Файлы для хранения переменных окружения.
* `requirements.txt`: Список всех зависимостей проекта.
* `manage.py`: Утилита командной строки Django для выполнения административных задач.

## Установка и запуск

Следуйте этим шагам, чтобы настроить и запустить проект локально.

### 1. Клонирование репозитория

```
    git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
    cd SkillShare
```

### 2. Создание и активация виртуального окружения

Рекомендуется создать окружение в папке .venv (PyCharm умеет автоматически подхватывать .venv), но можно использовать любое имя (например venv).

Windows (PowerShell)

```
python -m venv .venv
# активировать в текущем сеансе PowerShell (dot-sourcing: точка + пробел)
# если политика выполнения блокирует, можно временно разрешить для текущего процесса:
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
. .\.venv\Scripts\Activate.ps1
```

Windows (CMD)

```
python -m venv venv
.venv\Scripts\activate.bat
```

Git Bash / WSL / macOS / Linux

```
python3 -m venv .venv
source .venv/bin/activate
```

Примечание: если вы не хотите/не можете активировать окружение, можно запускать pip через конкретный python из venv без активации:

```
.\.venv\Scripts\python.exe -m pip install --upgrade pip setuptools wheel
.\.venv\Scripts\python.exe -m pip install -r requirements.txt
```

После активации рекомендуется использовать:

```
python -m pip install --upgrade pip setuptools wheel
python -m pip install -r requirements.txt
```


### 3. Установка зависимостей

Установите все необходимые библиотеки из requirements.txt:

```
    pip install -r requirements.txt
```
### 4. Установка и запуск с Docker

Для упрощения развертывания и обеспечения единообразной среды разработки, проект можно запускать с использованием Docker и Docker Compose.

**1. Убедитесь, что Docker установлен:**

Вам потребуется Docker Desktop (для Windows/macOS) или Docker Engine (для Linux). Установите его, если он еще не установлен:

*   **Docker Desktop (Windows/macOS):** [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
*   **Docker Engine (Linux):** Следуйте инструкциям для вашего дистрибутива на [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)

**2. Проект использует PostgreSQL.** 

Убедитесь, что у вас установлен и запущен PostgreSQL, и создайте базу данных, указанную в `.env.`

**3. Настройка переменных окружения:**

**Создайте файл `.env` в корне проекта на основе `.env.example` и заполните его необходимыми значениями.
Обязательно укажите:**

## Пример заполнения `.env`
```
SECRET_KEY=ваше_секретное_значение
```

**Настройки базы данных (POSTGRESQL):**
```
DB_NAME=<ваша БД>
DB_USER=<пользователь, например postgres>
DB_PASSWORD=<пароль БД>
DB_HOST=<например db, так как это имя сервиса в docker-compose или localhost>
DB_PORT=5432
```

**Настройки stripe:**
```
STRIPE_SECRET_KEY=sk_test_ваш_секретный_ключ
BASE_URL=http://localhost:8001
```

**Настройки Redis для Celery**::

Смотри [ниже](#5-установка-и-запуск-redis)

```
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
```

**Настройки Email:**:

**По умолчанию для тестирования в `settings.py` используется `django.core.mail.backends.console.EmailBackend`, который
  выводит письма в консоль.
  `EMAIL_HOST_USER` должен быть заполнен **валидным email-адресом (даже тестовым)**, чтобы избежать ошибок кодирования
  при
  отправке писем. Например:**
```
EMAIL_HOST_USER="noreply@skillshare.com"
DEFAULT_FROM_EMAIL="noreply@skillshare.com"
```

**Для реальной отправки писем через SMTP раскомментируйте соответствующие строки в `.env` и заполните их:**
```
EMAIL_BACKEND="django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST=smtp.your_email_provider.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_USE_SSL=False
EMAIL_HOST_USER=your_email@example.com
EMAIL_HOST_PASSWORD=your_email_password
```

**4. Запуск Docker Compose:**

Перейдите в корневую директорию проекта, где находится docker-compose.yaml, и выполните команду:
```
docker-compose up -d --build
```
- up: Запускает контейнеры, определенные в docker-compose.yaml.
- -d: Запускает контейнеры в фоновом режиме (detached mode).
- --build: Пересобирает образы Docker перед запуском, если были изменения в Dockerfile или контексте сборки.
- Используйте это при первом запуске или после внесения изменений в зависимости/Dockerfile.

**Что произойдет после запуска:**

Docker Compose создаст и запустит несколько сервисов:

- db: Контейнер PostgreSQL (база данных).
- redis: Контейнер Redis (брокер сообщений для Celery, кеширование).
- backend: Контейнер с вашим Django-приложением. При первом запуске он выполнит миграции базы данных, загрузит начальные данные (фикстуры) и запустит Django-сервер.

* **Выполнение миграций и загрузка данных (только при первом запуске):
Если вы запускаете проект в первый раз, Docker Compose автоматически выполнит миграции базы данных и загрузит начальные фикстуры. 
Вы можете убедиться в этом, просмотрев логи контейнера backend:**
* 
  ```
      docker-compose logs backend
  ```

* **или выполнив команды вручную, если это необходимо:**

    ```
    docker-compose exec backend python manage.py migrate
    docker-compose exec backend python manage.py load_initial_data
    ```

- celery_worker: Контейнер с Celery Worker для обработки асинхронных задач.
- celery_beat: Контейнер с Celery Beat для планирования периодических задач.

После запуска, Django-сервер будет доступен по адресу http://localhost:8001/.
Вы будете автоматически перенаправлены на интерактивную документацию API (Swagger UI).

**5. Проверка состояния контейнеров:**

Чтобы убедиться, что все контейнеры запущены и работают, используйте:
```
docker-compose ps
```
**6. Остановка и удаление контейнеров:**

- **Остановка (без удаления данных):**
```
docker-compose stop
```

- **Остановка и удаление контейнеров, сетей и томов (volumes) с данными:**
```
docker-compose down -v
```
### `Используйте -v, чтобы также удалить тома с данными базы данных и медиафайлами, если вы хотите начать "с чистого листа".`

**7. Запуск команд внутри контейнера (например, createsuperuser):**

### Вам может потребоваться выполнить команды Django внутри работающего контейнера backend. Например, для создания суперпользователя:
```
docker-compose exec backend python manage.py createsuperuser
```
Далее следуйте подсказкам в терминале.

**8. Настройка PyCharm (Run/Debug Configurations):**

Для удобства разработки вы можете настроить PyCharm для запуска и отладки проекта через Docker Compose.

1. Откройте Run -> Edit Configurations...
2. Нажмите + и выберите Docker Compose.
3. Name: Присвойте осмысленное имя, например, SkillShare Backend (Docker).
4. Configuration files: Укажите путь к вашему docker-compose.yaml (обычно просто docker-compose.yaml).
5. Service: Выберите backend. Это сервис, который запускает ваш Django-сервер.
    Before launch:
- Рекомендуется добавить шаг Build для сервиса backend, чтобы PyCharm автоматически пересобирал образ при изменениях в Dockerfile. Нажмите + -> Build service images. Выберите backend.
- Убедитесь, что базы данных и Redis готовы. Вы можете добавить шаги Run another configuration и выбрать Docker Compose для db и redis с командой up или start. Однако, depends_on в docker-compose.yaml и healthcheck обычно достаточно, чтобы backend ждал эти сервисы.

6. Environment variables: PyCharm автоматически подтянет переменные из вашего .env файла, если он находится в корне проекта.
7. Path mappings: Убедитесь, что пути к вашему проекту на локальной машине и внутри контейнера правильно сопоставлены (.:/app должно быть установлено по умолчанию, если вы используете build: .).
8. Command: Установите python manage.py runserver 0.0.0.0:8000. PyCharm может автоматически предложить это.

### **После настройки вы сможете запускать и отлаживать ваш Django-проект, используя кнопки Run/Debug в PyCharm, и он будет взаимодействовать с базой данных и Redis внутри Docker-контейнеров.**

### Переход по ссылке:

**После успешного запуска проекта через Docker Compose (или PyCharm), ваш API будет доступен по адресу:**

- API Documentation (Swagger UI): http://localhost:8001/api/schema/swagger-ui/

Вы можете перейти по этой ссылке в браузере, чтобы просмотреть интерактивную документацию и тестировать ваши API-эндпоинты. 
Для эндпоинтов, требующих аутентификации, используйте раздел "Аутентификация (JWT)". Смотри [ниже](#аутентификация-jwt) в этом README.

# N.B.:
**Проект включает кастомную команду для загрузки тестовых данных (пользователей, курсов, уроков, платежей) из фикстуры
materials/fixtures/initial_data.json. Эта команда также удаляет существующие данные перед загрузкой, чтобы избежать
дублирования.**

**Если вы вдруг захотите загрузить фикстуру вручную (без удаления существующих данных), используйте:**
```
    python -Xutf8 manage.py loaddata materials/fixtures/initial_data.json
```
**Чтобы создать фикстуру с уже имеющими у Вас данными используйте это:**
```
     python -Xutf8 manage.py dumpdata users.user materials.course materials.lesson users.payment --indent 4 > materials/fixtures/initial_data.json
```

### 5. Установка и запуск Redis


**Если вы используете Docker Compose (рекомендуется):**

Redis уже настроен как сервис в `docker-compose.yaml` и будет запущен автоматически при выполнении `docker-compose up`.
Вам не нужно устанавливать его отдельно на вашей машине.

**Если вы не используете Docker Compose и запускаете проект локально:**

Redis требуется для работы Celery и кеширования (настроен в `settings.py` через `CELERY_BROKER_URL` и `CELERY_RESULT_BACKEND`).
Redis требуется для работы кеширования (настроен в `settings.py` через `CACHES`).

## Установка

**Windows**:

1. Скачайте Redis с [официального репозитория](https://github.com/microsoftarchive/redis/releases)
2. Установите через установщик или запустите `redis-server.exe` напрямую

**Linux**:

```
    sudo apt update
    sudo apt install redis
```

## Запуск

**Windows:**

```
    redis-server.exe
```

**Linux:**

```
    sudo service redis start
    # Или
    redis-server
```

## Проверка

```
    redis-cli ping
    # Ожидаемый ответ: PONG
```

# Функционал Celery Задач

Проект использует Celery для выполнения фоновых и периодических задач. Настройки Celery, включая расписание для Celery
Beat, определены в skillshare_platform/settings.py.

## 1. Отправка уведомлений об обновлении курсов (materials.tasks.send_course_update_notification)

Эта задача отвечает за асинхронную рассылку писем пользователям, подписанным на курс, когда материалы курса обновляются.

**Как это работает:**
- Когда курс (или его урок) обновляется через API (CourseViewSet.perform_update или
LessonRetrieveUpdateDestroyAPIView.perform_update), запускается задача send_course_update_notification.

- Задача отправляется асинхронно в Celery Worker.

- Уведомление отправляется, только если более четырех часов прошло с момента последнего уведомления о данном курсе, чтобы
избежать спама.

- Письма отправляются индивидуально каждому подписчику курса.

## 2. Деактивация неактивных пользователей (materials.tasks.deactivate_inactive_users)

Это периодическая задача, которая автоматически деактивирует пользователей, не заходивших на сайт в течение длительного
времени.

**Как это работает:**
- Задача запускается Celery Beat по расписанию, определенному в skillshare_platform/settings.py (по умолчанию, раз в 30
дней).

- Она проверяет поле last_login у всех активных пользователей, исключая суперпользователей.

- Если пользователь не заходил более одного месяца, его аккаунт деактивируется (is_active устанавливается в False).

- Каждому деактивированному пользователю отправляется индивидуальное уведомление по электронной почте о деактивации
аккаунта.

# Использование API

**Автоматическое перенаправление на документацию:**
При доступе к корневому URL вашего сервера (`http://127.0.0.1:8001/`), вы будете автоматически перенаправлены на
интерактивную документацию API (Swagger UI) по адресу `http://127.0.0.1:8001/api/schema/swagger-ui/`.

Вы можете взаимодействовать с API с помощью инструментов, таких как Postman, Insomnia или непосредственно через браузер.

## Аутентификация (JWT)

Для получения токенов и доступа к защищенным эндпоинтам используйте следующие шаги:

1. **Получение токенов (логин)**:
    * **Эндпоинт**: `POST /api/token/`
    * **Тело запроса (JSON)**:
      ```json
      {
          "email": "ваш_email",
          "password": "ваш_пароль"
      }
      ```
    * **Ответ**: `{"refresh": "...", "access": "..."}`

2. **Использование Access Token**:
    * Включите `access` токен в заголовок `Authorization` для всех защищенных запросов:
      `Authorization: Bearer <ваш_access_токен>`

3. **Обновление Access Token**:
    * **Эндпоинт**: `POST /api/token/refresh/`
    * **Тело запроса (JSON)**:
      ```json
      {
          "refresh": "ваш_refresh_токен"
      }
      ```
    * **Ответ**: `{"access": "..."}`

# Админ-панель Django

Доступ к админ-панели: `http://127.0.0.1:8001/admin/`
Используйте учетные данные суперпользователя, созданные ранее, для входа.

# Права доступа и роли

Проект реализует гибкую систему прав доступа на основе ролей пользователей:

* **Суперпользователь (Администратор)**:
    * **Полный доступ** к просмотру, созданию, редактированию и удалению **всех курсов и уроков**.
    * Может **просматривать, редактировать и удалять всех пользователей**.
    * Может **просматривать список всех платежей**.

* **Модератор**:
    * **Просмотр всех курсов и уроков**.
    * **Редактирование всех курсов и уроков**, но **не может их удалять**.
    * **Не может создавать** новые курсы или уроки.
    * Может **просматривать список всех пользователей и их детали**.
    * Может **редактировать и удалять свой собственный профиль** через API.
    * Может **просматривать список всех платежей**.

* **Владелец курса/урока (обычный пользователь)**:
    * **Просмотр, создание, редактирование и удаление только своих** курсов и уроков.
    * Может **просматривать список всех пользователей и их детали**.
    * Может **редактировать и удалять свой собственный профиль** через API.
    * Может **просматривать список всех платежей** (текущая реализация позволяет видеть все платежи, а не только свои).

* **Неавторизованный пользователь**:
    * Единственное доступное действие — **регистрация нового пользователя** (`POST /api/users/`).
    * Все остальные эндпоинты требуют аутентификации.

# Основные эндпоинты API

Базовый URL для всех API-запросов: `http://127.0.0.1:8001/api/`

## Пользователи

- **Регистрация нового пользователя**: `POST /api/users/` (доступно без аутентификации)
- **Получить список пользователей**: `GET /api/users/` (требуется аутентификация)
- **Получить детали пользователя (включая платежи)**: `GET /api/users/{id}/` (требуется аутентификация)
- **Обновить свой профиль**: `PUT /api/profile/` (требуется аутентификация)

## Платежи

- **Получить список платежей**: `GET /api/payments/` (требуется аутентификация)

## Сортировка:

- **По дате оплаты (по возрастанию)**: `GET /api/payments/?ordering=payment_date`
- **По дате оплаты (по убыванию)**: `GET /api/payments/?ordering=-payment_date`

## Комбинированная фильтрация и сортировка:

- `GET /api/payments/?paid_course=1&payment_method=cash&ordering=-payment_date`

# Курсы

- **Получить список курсов**: `GET /api/courses/` (требуется аутентификация)
- **Получить детали курса (включая уроки и их количество)**: `GET /api/courses/{id}/` (требуется аутентификация)

# Уроки

- **Получить список уроков**: `GET /api/lessons/` (требуется аутентификация)
- **Получить детали урока**: `GET /api/lessons/{id}/` (требуется аутентификация)

# Пример использования в Postman

- Запустите сервер Django.
- Откройте Postman.
- Создайте новый запрос.
- Выберите метод `GET`.
- Введите URL, например: `http://127.0.0.1:8001/api/payments/?payment_method=cash&ordering=-payment_date`
- Нажмите "Send".

# Интеграция Stripe

Проект интегрирован со Stripe для обработки платежей.

## Настройка Stripe API ключей

Для работы с платежами Stripe вам потребуется получить ключи API.
Используйте тестовые ключи для разработки.

1.  **Зарегистрируйтесь или войдите в аккаунт Stripe:**
    Перейдите на [https://dashboard.stripe.com/](https://dashboard.stripe.com/)

2.  **Получите API ключи:**
    *   В вашей панели управления Stripe перейдите в раздел **"Разработчики"** (Developers) -> **"Ключи API"** (API keys).
    *   Вам понадобятся:
        *   **Publishable key (публикуемый ключ)**: Используется на фронтенде (если есть) и обычно не является секретным.
        *   **Secret key (секретный ключ)**: Используется на бэкенде и должен храниться в строжайшем секрете.
    *   Убедитесь, что вы используете **тестовые ключи** для разработки, которые начинаются с `pk_test_` и `sk_test_`.

3.  **Добавьте секретный ключ в ваш `.env` файл:**
    В корневом файле `.env` добавьте или обновите переменную `STRIPE_SECRET_KEY`:

    ```
    STRIPE_SECRET_KEY=sk_test_ваш_секретный_ключ
    ```

## Инициирование платежа

Для создания новой платежной сессии Stripe используйте следующий эндпоинт:

- **Создать платеж**: `POST /api/payments/create/` (требуется аутентификация)
    * **Тело запроса (JSON)**: Необходимо указать либо `paid_course`, либо `paid_lesson`.

  ```json
  {
      "paid_course": 1
  }
  ```
  или
  ```json
  {
      "paid_lesson": 5
  }
  ```

    * **Ответ**: При успешном запросе возвращается `payment_url`, на который пользователь должен быть перенаправлен для
      завершения оплаты.

  ```json
  {
      "payment_id": 123,
      "payment_url": "https://checkout.stripe.com/c/pay/cs_test_...",
      "amount": "123.45",
      "status": "pending"
  }
  ```

## Обработка колбэков Stripe

Stripe перенаправляет пользователя на следующие URL после завершения или отмены платежа. Эти эндпоинты обрабатывают
изменения статуса платежей в вашей системе:

- **Успешная оплата**: `GET /success/`
    * Stripe автоматически добавляет параметр `session_id`. Пример:
      `http://127.0.0.1:8001/success/?session_id=cs_test_...`
    * Этот эндпоинт обновляет статус соответствующего платежа в вашей базе данных на `succeeded`.
- **Отмена оплаты**: `GET /cancel/`
    * Stripe перенаправляет пользователя на этот URL, если платеж был отменен.
    * Этот эндпоинт обновляет статус соответствующего платежа в вашей базе данных на `failed`.

Вы получите JSON-ответ со списком платежей, отфильтрованных по способу оплаты "Наличные" и отсортированных по дате
оплаты в убывающем порядке.

### 6. Запуск тестов

Для тестирования функциональности приложения `materials` используются `pytest` и `pytest-cov` для проверки покрытия
кода.

**Запуск всех тестов для приложения `materials`:**

```
    pytest materials/
```

**Запуск тестов и получение отчета о покрытии кода в консоли:**

```
    pytest materials/ --cov=materials
```

**Запуск тестов и генерация HTML-отчета о покрытии кода:**

```
    pytest --cov=materials --cov-report=html
```

После выполнения этой команды будет создана директория `htmlcov/` в корне проекта. Откройте файл `htmlcov/index.html` в
вашем браузере, чтобы просмотреть подробный отчет о покрытии.

### 7. Технологии

Проект разработан с использованием следующих основных технологий:

* **Backend**: Django, Django REST Framework
* **База данных**: PostgreSQL
* **Аутентификация**: JWT (JSON Web Tokens)
* **Платежи**: Stripe
* **Документация API**: DRF Spectacular
* **Контейнеризация**: Docker

# Заключение

Этот проект предоставляет надежную основу для создания платформы онлайн-обучения, с акцентом на простоту развертывания с использованием Docker. Он демонстрирует лучшие практики
разработки на Django REST Framework, включая структурирование кода, использование сериализаторов, ViewSet'ов, фильтрации, кастомных команд
и интеграцию сторонних сервисов, таких как Stripe и Celery.
