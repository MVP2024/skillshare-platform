# SkillShare Platform Backend

![Django](https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=django&logoColor=green)
![Django REST Framework](https://img.shields.io/badge/DRF-FF1709?style=for-the-badge&logo=django&logoColor=white)
![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)
![PostgreSQL](https://img.shields.io/badge/PostgreSQL-316192?style=for-the-badge&logo=postgresql&logoColor=white)
![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white)
![GitHub](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white)

## Описание проекта

Этот проект представляет собой бэкенд для платформы онлайн-обучения, аналогичной SkillShare, разработанный с
использованием Django и Django REST Framework. Он предоставляет API для управления пользователями, курсами, уроками и
платежами.

### Основные возможности:

* **Управление пользователями**: Регистрация, авторизация, профили пользователей.
* **Курсы и уроки**: Создание, просмотр, обновление и удаление курсов и уроков.
* **Платежи**: Запись и отслеживание платежей за курсы и уроки.
* **Фильтрация и сортировка**: Гибкие возможности для поиска и упорядочивания платежей.
* **История платежей**: Просмотр истории платежей в профиле пользователя.
* **Ролевая модель доступа**: Разграничение прав доступа для суперпользователей, модераторов и обычных пользователей (
  владельцев контента).
* **Автоматическая пагинация**: Пагинация списков курсов и уроков для оптимизации загрузки данных.
* **Загрузка начальных данных**: Кастомная команда для удобной загрузки тестовых данных (пользователей, курсов, уроков,
  платежей, групп).
* **Платежная система**: Интеграция со Stripe для обработки платежей за курсы и уроки.
* **Фоновые задачи с Celery**:
    * Асинхронная отправка уведомлений об обновлении курсов.
    * Периодическая деактивация неактивных пользователей.

## Структура проекта

* `skillshare_platform/`: Основные настройки проекта Django, корневые URL-адреса.
* `users/`: Приложение для управления пользователями, их профилями и платежами. Содержит модели `User` и `Payment`,
  сериализаторы, представления и URL-адреса.
* `materials/`: Приложение для управления учебными материалами (курсами и уроками). Содержит модели `Course` и `Lesson`,
  сериализаторы, представления и URL-адреса.
* `media/`: Директория для хранения загружаемых пользователями файлов (аватары, превью курсов/уроков).
* `env/`, `.venv/`: Виртуальные окружения (игнорируются Git).
* `.env`, `.env.example`: Файлы для хранения переменных окружения.
* `requirements.txt`: Список всех зависимостей проекта.
* `manage.py`: Утилита командной строки Django для выполнения административных задач.

## Установка и запуск

Следуйте этим шагам, чтобы настроить и запустить проект локально.

### 1. Клонирование репозитория

```
    git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
    cd SkillShare
```

### 2. Создание и активация виртуального окружения

Рекомендуется использовать виртуальное окружение для изоляции зависимостей проекта.

Для Windows:

```
    python -m venv .venv
    .venv\Scripts\activate
```

Для macOS/Linux:

```
    python3 -m venv .venv
    source .venv/bin/activate
```

### 3. Установка зависимостей

Установите все необходимые библиотеки из requirements.txt:

```
    pip install -r requirements.txt
```

### 4. Настройка переменных окружения

Создайте файл `.env` в корне проекта на основе `.env.example` и заполните его необходимыми значениями.
Обязательно укажите:

* `SECRET_KEY`
* Настройки базы данных (`DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_HOST`, `DB_PORT`)
* Ключи Stripe (`STRIPE_SECRET_KEY`, `BASE_URL`)
* **Настройки Redis для Celery**:

```dotenv
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
```

* **Настройки Email**:
  По умолчанию для тестирования в `settings.py` используется `django.core.mail.backends.console.EmailBackend`, который
  выводит письма в консоль.
  `EMAIL_HOST_USER` должен быть заполнен **валидным email-адресом (даже тестовым)**, чтобы избежать ошибок кодирования
  при
  отправке писем. Например:

```dotenv
EMAIL_HOST_USER="noreply@skillshare.com"
DEFAULT_FROM_EMAIL="noreply@skillshare.com"
```

Для реальной отправки писем через SMTP раскомментируйте соответствующие строки в `.env` и заполните их:

```dotenv
# EMAIL_BACKEND="django.core.mail.backends.smtp.EmailBackend"
# EMAIL_HOST=smtp.your_email_provider.com
# EMAIL_PORT=587
# EMAIL_USE_TLS=True
# EMAIL_USE_SSL=False
# EMAIL_HOST_USER=your_email@example.com
# EMAIL_HOST_PASSWORD=your_email_password
```

### 5. Настройка базы данных

Проект использует PostgreSQL. Убедитесь, что у вас установлен и запущен PostgreSQL,
и создайте базу данных, указанную в .env.

### 6. Выполнение миграций

После любых изменений в моделях Django необходимо создать файлы миграций,
а затем применить их для обновления структуры базы данных.

**Создание файлов миграций:**

```
    python manage.py makemigrations
```

Примените миграции для создания таблиц в базе данных:

```
    python manage.py migrate
```

### 7. Загрузка начальных данных (фикстуры)

Проект включает кастомную команду для загрузки тестовых данных (пользователей, курсов, уроков, платежей) из фикстуры
materials/fixtures/initial_data.json. Эта команда также удаляет существующие данные перед загрузкой, чтобы избежать
дублирования.

```
    python -Xutf8 manage.py load_initial_data
```

**Важное примечание:**
При использовании команды `load_initial_data` для тестирования функционала деактивации
пользователей, убедитесь, что вы
**не входите под пользователем, который должен быть деактивирован (
например, `user2@a.com`)**, так как это обновит его `last_login` и предотвратит деактивацию.

Если вы хотите загрузить фикстуру вручную (без удаления существующих данных), используйте:

```
    python -Xutf8 manage.py loaddata materials/fixtures/initial_data.json
```

Чтобы создать фикстуру с уже имеющими у Вас данными используйте это:

```
     python -Xutf8 manage.py dumpdata users.user materials.course materials.lesson users.payment --indent 4 > materials/fixtures/initial_data.json
```

### 8. Создание суперпользователя (для доступа к админ-панели)

```
    python manage.py createsuperuser
```

Следуйте инструкциям в консоли для создания учетной записи суперпользователя.

### 9. Установка и запуск Redis

Redis требуется для работы кеширования (настроен в `settings.py` через `CACHES`).

## Установка

**Windows**:

1. Скачайте Redis с [официального репозитория](https://github.com/microsoftarchive/redis/releases)
2. Установите через установщик или запустите `redis-server.exe` напрямую

**Linux**:

```
    sudo apt update
    sudo apt install redis
```

## Запуск

**Windows:**

```
    redis-server.exe
```

**Linux:**

```
    sudo service redis start
    # Или
    redis-server
```

## Проверка

```
    redis-cli ping
    # Ожидаемый ответ: PONG

   ```

Убедитесь, что сервер Redis запущен перед запуском приложения.

### 10. Запуск Celery Worker

Откройте новый терминал и запустите Celery Worker. На Windows обязательно используйте флаг -P solo для однопоточного
режима, чтобы избежать проблем с многопроцессорностью.

```
    # На Windows
    celery -A skillshare_platform worker -l info -E -P solo
```

```
    # На Linux/macOS
    celery -A skillshare_platform worker -l info -E

```

### 11. Запуск Celery Beat

Откройте еще один новый терминал и запустите Celery Beat. Он будет планировать периодические задачи.

```
    celery -A skillshare_platform beat -l info
```

### 12. Запуск сервера разработки

```
    python manage.py runserver
```

Сервер будет доступен по адресу `http://127.0.0.1:8000/`.

# Функционал Celery Задач

Проект использует Celery для выполнения фоновых и периодических задач. Настройки Celery, включая расписание для Celery
Beat, определены в skillshare_platform/settings.py.

## 1. Отправка уведомлений об обновлении курсов (materials.tasks.send_course_update_notification)

Эта задача отвечает за асинхронную рассылку писем пользователям, подписанным на курс, когда материалы курса обновляются.

**Как это работает:**
- Когда курс (или его урок) обновляется через API (CourseViewSet.perform_update или
LessonRetrieveUpdateDestroyAPIView.perform_update), запускается задача send_course_update_notification.

- Задача отправляется асинхронно в Celery Worker.

- Уведомление отправляется, только если более четырех часов прошло с момента последнего уведомления о данном курсе, чтобы
избежать спама.

- Письма отправляются индивидуально каждому подписчику курса.

## 2. Деактивация неактивных пользователей (materials.tasks.deactivate_inactive_users)

Это периодическая задача, которая автоматически деактивирует пользователей, не заходивших на сайт в течение длительного
времени.

**Как это работает:**
- Задача запускается Celery Beat по расписанию, определенному в skillshare_platform/settings.py (по умолчанию, раз в 30
дней).

- Она проверяет поле last_login у всех активных пользователей, исключая суперпользователей.

- Если пользователь не заходил более одного месяца, его аккаунт деактивируется (is_active устанавливается в False).

- Каждому деактивированному пользователю отправляется индивидуальное уведомление по электронной почте о деактивации
аккаунта.

# Использование API

**Автоматическое перенаправление на документацию:**
При доступе к корневому URL вашего сервера (`http://127.0.0.1:8000/`), вы будете автоматически перенаправлены на
интерактивную документацию API (Swagger UI) по адресу `http://127.0.0.1:8000/api/schema/swagger-ui/`.

Вы можете взаимодействовать с API с помощью инструментов, таких как Postman, Insomnia или непосредственно через браузер.

## Аутентификация (JWT)

Для получения токенов и доступа к защищенным эндпоинтам используйте следующие шаги:

1. **Получение токенов (логин)**:
    * **Эндпоинт**: `POST /api/token/`
    * **Тело запроса (JSON)**:
      ```json
      {
          "email": "ваш_email",
          "password": "ваш_пароль"
      }
      ```
    * **Ответ**: `{"refresh": "...", "access": "..."}`

2. **Использование Access Token**:
    * Включите `access` токен в заголовок `Authorization` для всех защищенных запросов:
      `Authorization: Bearer <ваш_access_токен>`

3. **Обновление Access Token**:
    * **Эндпоинт**: `POST /api/token/refresh/`
    * **Тело запроса (JSON)**:
      ```json
      {
          "refresh": "ваш_refresh_токен"
      }
      ```
    * **Ответ**: `{"access": "..."}`

# Админ-панель Django

Доступ к админ-панели: `http://127.0.0.1:8000/admin/`
Используйте учетные данные суперпользователя, созданные ранее, для входа.

# Права доступа и роли

Проект реализует гибкую систему прав доступа на основе ролей пользователей:

* **Суперпользователь (Администратор)**:
    * **Полный доступ** к просмотру, созданию, редактированию и удалению **всех курсов и уроков**.
    * Может **просматривать, редактировать и удалять всех пользователей**.
    * Может **просматривать список всех платежей**.

* **Модератор**:
    * **Просмотр всех курсов и уроков**.
    * **Редактирование всех курсов и уроков**, но **не может их удалять**.
    * **Не может создавать** новые курсы или уроки.
    * Может **просматривать список всех пользователей и их детали**.
    * Может **редактировать и удалять свой собственный профиль** через API.
    * Может **просматривать список всех платежей**.

* **Владелец курса/урока (обычный пользователь)**:
    * **Просмотр, создание, редактирование и удаление только своих** курсов и уроков.
    * Может **просматривать список всех пользователей и их детали**.
    * Может **редактировать и удалять свой собственный профиль** через API.
    * Может **просматривать список всех платежей** (текущая реализация позволяет видеть все платежи, а не только свои).

* **Неавторизованный пользователь**:
    * Единственное доступное действие — **регистрация нового пользователя** (`POST /api/users/`).
    * Все остальные эндпоинты требуют аутентификации.

# Основные эндпоинты API

Базовый URL для всех API-запросов: `http://127.0.0.1:8000/api/`

## Пользователи

- **Регистрация нового пользователя**: `POST /api/users/` (доступно без аутентификации)
- **Получить список пользователей**: `GET /api/users/` (требуется аутентификация)
- **Получить детали пользователя (включая платежи)**: `GET /api/users/{id}/` (требуется аутентификация)
- **Обновить свой профиль**: `PUT /api/profile/` (требуется аутентификация)

## Платежи

- **Получить список платежей**: `GET /api/payments/` (требуется аутентификация)

## Сортировка:

- **По дате оплаты (по возрастанию)**: `GET /api/payments/?ordering=payment_date`
- **По дате оплаты (по убыванию)**: `GET /api/payments/?ordering=-payment_date`

## Комбинированная фильтрация и сортировка:

- `GET /api/payments/?paid_course=1&payment_method=cash&ordering=-payment_date`

# Курсы

- **Получить список курсов**: `GET /api/courses/` (требуется аутентификация)
- **Получить детали курса (включая уроки и их количество)**: `GET /api/courses/{id}/` (требуется аутентификация)

# Уроки

- **Получить список уроков**: `GET /api/lessons/` (требуется аутентификация)
- **Получить детали урока**: `GET /api/lessons/{id}/` (требуется аутентификация)

# Пример использования в Postman

- Запустите сервер Django.
- Откройте Postman.
- Создайте новый запрос.
- Выберите метод `GET`.
- Введите URL, например: `http://127.0.0.1:8000/api/payments/?payment_method=cash&ordering=-payment_date`
- Нажмите "Send".

# Интеграция Stripe

Проект интегрирован со Stripe для обработки платежей.

## Инициирование платежа

Для создания новой платежной сессии Stripe используйте следующий эндпоинт:

- **Создать платеж**: `POST /api/payments/create/` (требуется аутентификация)
    * **Тело запроса (JSON)**: Необходимо указать либо `paid_course`, либо `paid_lesson`.

  ```json
  {
      "paid_course": 1
  }
  ```
  или
  ```json
  {
      "paid_lesson": 5
  }
  ```

    * **Ответ**: При успешном запросе возвращается `payment_url`, на который пользователь должен быть перенаправлен для
      завершения оплаты.

  ```json
  {
      "payment_id": 123,
      "payment_url": "https://checkout.stripe.com/c/pay/cs_test_...",
      "amount": "123.45",
      "status": "pending"
  }
  ```

## Обработка колбэков Stripe

Stripe перенаправляет пользователя на следующие URL после завершения или отмены платежа. Эти эндпоинты обрабатывают
изменения статуса платежей в вашей системе:

- **Успешная оплата**: `GET /success/`
    * Stripe автоматически добавляет параметр `session_id`. Пример:
      `http://127.0.0.1:8000/success/?session_id=cs_test_...`
    * Этот эндпоинт обновляет статус соответствующего платежа в вашей базе данных на `succeeded`.
- **Отмена оплаты**: `GET /cancel/`
    * Stripe перенаправляет пользователя на этот URL, если платеж был отменен.
    * Этот эндпоинт обновляет статус соответствующего платежа в вашей базе данных на `failed`.

Вы получите JSON-ответ со списком платежей, отфильтрованных по способу оплаты "Наличные" и отсортированных по дате
оплаты в убывающем порядке.

### 10. Запуск тестов

Для тестирования функциональности приложения `materials` используются `pytest` и `pytest-cov` для проверки покрытия
кода.

**Запуск всех тестов для приложения `materials`:**

```
    pytest materials/
```

**Запуск тестов и получение отчета о покрытии кода в консоли:**

```
    pytest materials/ --cov=materials
```

**Запуск тестов и генерация HTML-отчета о покрытии кода:**

```
    pytest --cov=materials --cov-report=html
```

После выполнения этой команды будет создана директория `htmlcov/` в корне проекта. Откройте файл `htmlcov/index.html` в
вашем браузере, чтобы просмотреть подробный отчет о покрытии.

### 13. Технологии

Проект разработан с использованием следующих основных технологий:

* **Backend**: Django, Django REST Framework
* **База данных**: PostgreSQL
* **Аутентификация**: JWT (JSON Web Tokens)
* **Платежи**: Stripe
* **Документация API**: DRF Spectacular

# Заключение

Этот проект предоставляет надежную основу для создания платформы онлайн-обучения. Он демонстрирует лучшие практики
разработки на Django REST Framework, включая структурирование кода, использование сериализаторов, ViewSet'ов, фильтрации
и кастомных команд.